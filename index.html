<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Economic Circulation Visualization - Globalism, Nationalism, Localism v2.1</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #ffffff;
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #ffffff;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        h1 {
            font-size: 2.5em;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #7f8c8d;
            font-size: 1.1em;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #e0e0e0;
        }

        .control-group h3 {
            margin-bottom: 15px;
            color: #2c3e50;
            font-size: 1.2em;
        }

        .mode-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .mode-btn {
            padding: 12px 20px;
            border: 2px solid #666666;
            background: white;
            color: #666666;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: normal;
            transition: all 0.3s ease;
        }

        .mode-btn:hover {
            background: #f5f5f5;
            transform: translateY(-2px);
        }

        .mode-btn.active {
            background: #666666;
            color: white;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .slider-group {
            margin-bottom: 15px;
        }

        .slider-group label {
            display: block;
            margin-bottom: 8px;
            color: #2c3e50;
            font-weight: normal;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #d3d3d3;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #666666;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #666666;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            border: none;
        }

        .canvas-container {
            position: relative;
            margin-bottom: 30px;
            background: #1a1a2e;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: inset 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        #economy-canvas {
            display: block;
            width: 100%;
            height: 800px; /* 縦幅を少し調整 */
        }

        /* 解説エリアのスタイル */
        .explanation-card {
            background: #fdfdfd;
            border: 1px solid #e0e0e0;
            border-left: 5px solid #666666;
            border-radius: 8px;
            padding: 25px;
            margin-top: 30px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            transition: all 0.3s ease;
        }

        .explanation-header {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }

        .explanation-title {
            font-size: 1.8em;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .explanation-subtitle {
            font-size: 1.1em;
            color: #7f8c8d;
            font-style: italic;
            font-weight: 500;
        }

        .explanation-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .explanation-section h4 {
            color: #2c3e50;
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .explanation-section ul {
            list-style-type: none;
            padding-left: 5px;
        }

        .explanation-section li {
            margin-bottom: 8px;
            padding-left: 15px;
            position: relative;
            line-height: 1.6;
        }

        .explanation-section li::before {
            content: "•";
            color: #666666;
            position: absolute;
            left: 0;
            font-weight: bold;
        }

        .feature-box {
            background: #f0f4f8;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            grid-column: 1 / -1;
        }

        .feature-title {
            font-weight: bold;
            color: #34495e;
            margin-bottom: 5px;
            display: block;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            h1 {
                font-size: 1.8em;
            }

            .controls {
                grid-template-columns: 1fr;
            }

            #economy-canvas {
                height: 600px;
            }

            .explanation-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Economic Circulation System</h1>
            <p class="subtitle">Three-Layer Economic Zone Circulation Model</p>
        </header>

        <div class="controls">
            <div class="control-group">
                <h3>Historical Presets</h3>
                <div class="mode-buttons">
                    <button class="mode-btn" id="feudal-btn">Feudal Localism</button>
                    <button class="mode-btn" id="modern-nationalism-btn">Modern Nationalism</button>
                    <button class="mode-btn" id="globalism-btn">Contemporary Globalism</button>
                    <button class="mode-btn" id="glocalism-btn">Post-Modern Glocalism</button>
                </div>
            </div>
            <div class="control-group">
                <h3>Circulation Rates</h3>
                <div class="slider-group">
                    <label for="local-national-rate">
                        Local - National Rate: <span id="local-national-value">70</span>%
                    </label>
                    <input type="range" id="local-national-rate" min="0" max="100" value="70" step="5">
                </div>
                <div class="slider-group">
                    <label for="national-global-rate">
                        National - Global Rate: <span id="national-global-value">70</span>%
                    </label>
                    <input type="range" id="national-global-rate" min="0" max="100" value="70" step="5">
                </div>
            </div>
            <div class="control-group">
                <h3>Attraction Forces</h3>
                <div class="slider-group">
                    <label for="local-strength">
                        Local Force: <span id="local-strength-value">150</span>%
                    </label>
                    <input type="range" id="local-strength" min="10" max="300" value="150" step="10">
                </div>
                <div class="slider-group">
                    <label for="national-strength">
                        National Force: <span id="national-strength-value">280</span>%
                    </label>
                    <input type="range" id="national-strength" min="10" max="500" value="280" step="10">
                </div>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="economy-canvas"></canvas>
        </div>

        <div id="explanation-card" class="explanation-card" style="display: none;">
            <div class="explanation-header">
                <h2 id="exp-title" class="explanation-title">タイトル</h2>
                <p id="exp-subtitle" class="explanation-subtitle">サブタイトル</p>
            </div>
            
            <div class="feature-box">
                <span class="feature-title">シミュレーション上の特徴</span>
                <p id="exp-features">特徴の説明...</p>
            </div>

            <div class="explanation-grid">
                <div class="explanation-section">
                    <h4>メリット</h4>
                    <ul id="exp-merits">
                        </ul>
                </div>
                <div class="explanation-section">
                    <h4>デメリット / 課題</h4>
                    <ul id="exp-demerits">
                        </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 全てのJavaScriptコードをここに統合
        console.log('スクリプト読み込み開始');

        // 解説データ
        const EXPLANATIONS = {
            'feudal': {
                title: "1. 封建的ローカリズム (Feudal Localism)",
                subtitle: "「閉じた共同体の平穏と停滞」",
                features: "ローカル内循環率100%、ナショナル間移動0%。パーティクルは青い「ローカル渦」の中に完全に閉じ込められ、外へ出ていきません。それぞれの地域が孤立しています。",
                merits: [
                    "<strong>高い安定性:</strong> 外部の経済ショック（恐慌やパンデミックなど）の影響をほぼ受けません。",
                    "<strong>共同体の結束:</strong> 顔の見える範囲での経済活動であるため、信頼関係（ソーシャルキャピタル）が醸成されやすく、格差が視覚化されにくいです。"
                ],
                demerits: [
                    "<strong>経済の停滞:</strong> 外部との交換がないため、技術革新や富の増幅が起きにくく、「ゼロサムゲーム」になりがちです。",
                    "<strong>個人の自由の制限:</strong> 共同体の掟が全てであり、個人の移動や職業選択の自由が著しく制限されます。"
                ]
            },
            'modern-nationalism': {
                title: "2. 近代ナショナリズム (Modern Nationalism)",
                subtitle: "「中央集権による富の増幅と均質化」",
                features: "ローカルからナショナルへ100%吸い上げられ、ナショナル内で100%循環します。青い渦（地方）からパーティクルが勢いよく緑の渦（国家）へ移動しますが、国家間（緑の渦同士）の交換は行われません。",
                merits: [
                    "<strong>効率的なインフラ整備:</strong> 富が中央に集まることで、鉄道やダム、軍事力などの大規模投資が可能になります。",
                    "<strong>ナショナルミニマムの保証:</strong> 国家単位での社会保障や教育制度が整備され、国民全体の生活水準が底上げされます。"
                ],
                demerits: [
                    "<strong>地方の疲弊（過疎化）:</strong> 地方（ローカル）から富と人が流出し、地方独自の文化や経済が空洞化します（ストロー効果）。",
                    "<strong>排他性:</strong> 国家という枠組みが強固になるあまり、他国との対立や貿易摩擦が生じやすくなります。"
                ]
            },
            'globalism': {
                title: "3. 現代グローバリズム (Contemporary Globalism)",
                subtitle: "「国境なき競争と格差の拡大」",
                features: "ナショナルな引力が非常に強く、かつ交換レートも高い状態です。パーティクルは猛烈な速度で移動し、ローカル・ナショナル・グローバルの境界を軽々と飛び越え、撹拌されます。",
                merits: [
                    "<strong>最大効率と富の最大化:</strong> 世界中のどこからでも最も安いコストで調達し、最も高く売れる場所で売るため、世界全体のマクロな富は最大化します。",
                    "<strong>イノベーションの加速:</strong> 知恵や技術が瞬時に共有され、新しいサービスが次々と生まれます。"
                ],
                demerits: [
                    "<strong>文化の喪失:</strong> どの国、どの街に行っても同じチェーン店、同じ風景という「場所性の喪失」が起きます。",
                    "<strong>システミック・リスク:</strong> 一箇所での破綻が瞬時に全世界へ波及します。また、「持てる者」と「持たざる者」の格差が極限まで拡大します。"
                ]
            },
            'glocalism': {
                title: "4. ポストモダン・グローカリズム (Post-Modern Glocalism)",
                subtitle: "「地球規模で考え、足元で行動する調和」",
                features: "ローカルからナショナルへの適度な流出（25%）はあるものの、ナショナルでの滞留率が高い（90%）状態。それぞれの層で適度な循環を保ちながら連携しています。",
                merits: [
                    "<strong>多様性の保持:</strong> 各ローカルが独自の文化や経済圏を維持しつつ、必要な部分は外部と連携します。「ここだけの価値」が重視されます。",
                    "<strong>持続可能性:</strong> 地産地消をベースにしつつ、グローバルな知見を取り入れることで、環境負荷を下げながら経済活動を維持できます。"
                ],
                demerits: [
                    "<strong>調整コストの増大:</strong> バランスを取るための高度な政治判断や、個人のリテラシーが要求されます。",
                    "<strong>実現の難易度:</strong> 理想的な状態ですが、バランスが崩れると中途半端な停滞や、既得権益の温床になるリスクも孕んでいます。"
                ]
            }
        };

        // Config クラス
        class Config {
            constructor() {
                this.nationalVortexCount = 3;
                this.globalVortexCount = 3;

                this.defaultLocalNationalRate = 0.7;
                this.defaultNationalGlobalRate = 0.7;

                this.particlesPerVortex = {
                    national: 300,
                    global: 450
                };

                this.vortexSizes = {
                    national: 140,
                    global: 320
                };

                this.vortexStrength = {
                    national: 1.5,
                    global: 2.8
                };

                this.colors = {
                    national: '#888888',
                    global: '#cccccc',
                    exchange: '#ffffff',
                    connection: 'rgba(255, 255, 255, 0.1)'
                };

                this.particleSize = 2;
                this.particleAlpha = 0.6;
                
                this.friction = 0.98;
                this.maxSpeed = 9;
                this.transferThreshold = 0.5;
            }
            
            getPresetMode(mode) {
                // シンプル化のため、ヒストリカルプリセット以外はbalancedを返す
                switch(mode) {
                    case 'extreme-globalism':
                        return {
                            localNationalRate: 0.3,
                            nationalGlobalRate: 0.05,
                            strengthMultiplier: { national: 0.4, global: 15.0 }
                        };
                    case 'extreme-localism':
                        return {
                            localNationalRate: 0.95,
                            nationalGlobalRate: 0.95,
                            strengthMultiplier: { national: 4.0, global: 0.3 }
                        };
                    default: // balanced
                        return {
                            localNationalRate: 0.7,
                            nationalGlobalRate: 0.7,
                            strengthMultiplier: { national: 2.0, global: 3.0 }
                        };
                }
            }
            
            getVortexPositions(canvasWidth, canvasHeight, type) {
                const positions = [];
                const count = this[`${type}VortexCount`];
                const radius = Math.min(canvasWidth, canvasHeight) * 0.22;
                
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2 + Math.PI / 2;
                    const x = canvasWidth / 2 + Math.cos(angle) * radius;
                    const y = canvasHeight / 2 + Math.sin(angle) * radius;
                    positions.push({ x, y });
                }
                
                return positions;
            }
        }

        // Vortex クラス
        class Vortex {
            constructor(x, y, radius, type, config) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.type = type;
                this.config = config;

                if (type === 'national') {
                    this.internalCirculationRate = config.defaultLocalNationalRate;
                    this.externalExchangeRate = 1 - config.defaultLocalNationalRate;
                } else if (type === 'global') {
                    this.internalCirculationRate = config.defaultNationalGlobalRate;
                    this.externalExchangeRate = 1 - config.defaultNationalGlobalRate;
                }

                this.baseStrength = config.vortexStrength[type];
                this.currentStrength = this.baseStrength;
                
                this.particles = [];
                this.connectedVortexes = [];
                
                this.color = config.colors[type];
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.parentVortex = null;
            }
            
            addParticle(particle) {
                if (!this.particles.includes(particle)) {
                    this.particles.push(particle);
                }
            }
            
            removeParticle(particle) {
                const index = this.particles.indexOf(particle);
                if (index > -1) {
                    this.particles.splice(index, 1);
                }
            }
            
            connectTo(vortex) {
                if (!this.connectedVortexes.includes(vortex)) {
                    this.connectedVortexes.push(vortex);
                }
            }
            
            calculateInternalForce(particle) {
                const dx = this.x - particle.x;
                const dy = this.y - particle.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 1) return { fx: 0, fy: 0 };

                const deadZoneRadius = this.radius * 0.5;

                if (distance < deadZoneRadius) {
                    const angle = Math.atan2(dy, dx);
                    const rotationAngle = angle + Math.PI / 2;
                    const rotationForce = (this.currentStrength * this.internalCirculationRate * 0.5) / (distance * 0.08);

                    return {
                        fx: Math.cos(rotationAngle) * rotationForce,
                        fy: Math.sin(rotationAngle) * rotationForce
                    };
                }

                const force = (this.currentStrength * this.internalCirculationRate * 2.0) / (distance * 0.08);
                const angle = Math.atan2(dy, dx);
                const rotationAngle = angle + Math.PI / 2;
                const rotationForce = force * 0.3;

                return {
                    fx: Math.cos(angle) * force + Math.cos(rotationAngle) * rotationForce,
                    fy: Math.sin(angle) * force + Math.sin(rotationAngle) * rotationForce
                };
            }
            
            calculateExternalForce(particle) {
                let totalFx = 0;
                let totalFy = 0;
                
                for (const otherVortex of this.connectedVortexes) {
                    const dx = otherVortex.x - particle.x;
                    const dy = otherVortex.y - particle.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 1) continue;
                    
                    const force = (otherVortex.currentStrength * this.externalExchangeRate * 6.0) / (distance * 0.08);
                    const angle = Math.atan2(dy, dx);
                    
                    totalFx += Math.cos(angle) * force;
                    totalFy += Math.sin(angle) * force;
                }
                
                return { fx: totalFx, fy: totalFy };
            }
            
            shouldTransferParticle(particle) {
                const dx = particle.x - this.x;
                const dy = particle.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const threshold = this.radius * (1.0 - this.externalExchangeRate * 0.5);
                
                if (distance > threshold) {
                    let closestVortex = null;
                    let closestDistance = Infinity;
                    
                    for (const vortex of this.connectedVortexes) {
                        const vdx = particle.x - vortex.x;
                        const vdy = particle.y - vortex.y;
                        const vdist = Math.sqrt(vdx * vdx + vdy * vdy);
                        
                        if (vdist < vortex.radius * 2.0 && vdist < closestDistance) {
                            closestDistance = vdist;
                            closestVortex = vortex;
                        }
                    }
                    
                    if (closestVortex && Math.random() < this.externalExchangeRate * 6) {
                        return closestVortex;
                    }
                }
                
                if (Math.random() < this.externalExchangeRate * 0.05) {
                    const randomIndex = Math.floor(Math.random() * this.connectedVortexes.length);
                    return this.connectedVortexes[randomIndex];
                }
                
                return null;
            }
            
            updateCirculationRates(internal, external) {
                this.internalCirculationRate = internal;
                this.externalExchangeRate = external;
            }
            
            updateStrength(multiplier) {
                this.currentStrength = this.baseStrength * multiplier;
            }
            
            draw(ctx, showConnections = true) {
                this.pulsePhase += 0.02;
                const pulse = Math.sin(this.pulsePhase) * 0.1 + 0.9;
                
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.radius * pulse
                );
                gradient.addColorStop(0, `${this.color}40`);
                gradient.addColorStop(0.5, `${this.color}20`);
                gradient.addColorStop(1, `${this.color}00`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * pulse, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.3, 0, Math.PI * 2);
                ctx.stroke();

                if (showConnections) {
                    ctx.strokeStyle = this.config.colors.connection;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([10, 10]);
                    
                    for (const vortex of this.connectedVortexes) {
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(vortex.x, vortex.y);
                        ctx.stroke();
                    }
                    
                    ctx.setLineDash([]);
                }
            }
            
            getStats() {
                return {
                    type: this.type,
                    particleCount: this.particles.length,
                    internalRate: (this.internalCirculationRate * 100).toFixed(0),
                    externalRate: (this.externalExchangeRate * 100).toFixed(0)
                };
            }
        }

        // Particle クラス
        class Particle {
            constructor(x, y, homeVortex, config) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                
                this.homeVortex = homeVortex;
                this.currentVortex = homeVortex;
                
                this.config = config;
                this.size = config.particleSize;
                this.alpha = config.particleAlpha;
                
                this.color = homeVortex.color;
                this.isTransferring = false;

                this.trail = [];
                this.maxTrailLength = 5;
            }
            
            calculateForces() {
                const internal = this.currentVortex.calculateInternalForce(this);
                const external = this.currentVortex.calculateExternalForce(this);

                const turbulence = 0.8;
                const randomFx = (Math.random() - 0.5) * turbulence;
                const randomFy = (Math.random() - 0.5) * turbulence;

                this.vx += internal.fx + external.fx + randomFx;
                this.vy += internal.fy + external.fy + randomFy;

                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > this.config.maxSpeed) {
                    this.vx = (this.vx / speed) * this.config.maxSpeed;
                    this.vy = (this.vy / speed) * this.config.maxSpeed;
                }

                this.vx *= this.config.friction;
                this.vy *= this.config.friction;
            }
            
            checkTransfer() {
                const targetVortex = this.currentVortex.shouldTransferParticle(this);
                
                if (targetVortex) {
                    this.currentVortex.removeParticle(this);
                    this.currentVortex = targetVortex;
                    this.currentVortex.addParticle(this);
                    
                    this.isTransferring = true;
                    setTimeout(() => {
                        this.isTransferring = false;
                    }, 500);
                }
            }
            
            update() {
                this.calculateForces();
                
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
                
                this.x += this.vx;
                this.y += this.vy;
                
                this.checkTransfer();
            }
            
            draw(ctx) {
                if (this.trail.length > 1) {
                    ctx.strokeStyle = `${this.color}30`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    
                    for (let i = 1; i < this.trail.length; i++) {
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    ctx.stroke();
                }
                
                const displayColor = this.isTransferring 
                    ? this.config.colors.exchange 
                    : this.color;
                
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.size * 2
                );
                gradient.addColorStop(0, `${displayColor}${Math.floor(this.alpha * 255).toString(16)}`);
                gradient.addColorStop(1, `${displayColor}00`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = displayColor;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // CirculationController クラス
        class CirculationController {
            constructor(vortexes, config) {
                this.vortexes = vortexes;
                this.config = config;
                this.currentMode = 'balanced';
            }
            
            setMode(mode) {
                this.currentMode = mode;
                const preset = this.config.getPresetMode(mode);
                this.applyPreset(preset);
            }
            
            applyPreset(preset) {
                this.vortexes.forEach(vortex => {
                    if (vortex.type === 'national') {
                        vortex.updateCirculationRates(
                            preset.localNationalRate,
                            1 - preset.localNationalRate
                        );
                    } else if (vortex.type === 'global') {
                        vortex.updateCirculationRates(
                            preset.nationalGlobalRate,
                            1 - preset.nationalGlobalRate
                        );
                    }

                    const multiplier = preset.strengthMultiplier[vortex.type];
                    vortex.updateStrength(multiplier);
                });
            }
            
            setCustomRates(localNationalRate, nationalGlobalRate) {
                this.currentMode = 'custom';
                this.vortexes.forEach(vortex => {
                    if (vortex.type === 'national') {
                        vortex.updateCirculationRates(localNationalRate, 1 - localNationalRate);
                    } else if (vortex.type === 'global') {
                        vortex.updateCirculationRates(nationalGlobalRate, 1 - nationalGlobalRate);
                    }
                });
            }

            setAttractionForces(localForce, nationalForce) {
                this.vortexes.forEach(vortex => {
                    if (vortex.type === 'national') {
                        vortex.currentStrength = localForce / 100;
                    } else if (vortex.type === 'global') {
                        vortex.currentStrength = nationalForce / 100;
                    }
                });
            }

            getHistoricalPreset(presetName) {
                const presets = {
                    'feudal': {
                        localNationalRate: 100,
                        nationalGlobalRate: 0,
                        localForce: 260,
                        nationalForce: 10,
                    },
                    'modern-nationalism': {
                        localNationalRate: 0,
                        nationalGlobalRate: 100,
                        localForce: 80,
                        nationalForce: 150,
                    },
                    'globalism': {
                        localNationalRate: 65,
                        nationalGlobalRate: 60,
                        localForce: 60,
                        nationalForce: 480,
                    },
                    'glocalism': {
                        localNationalRate: 25,
                        nationalGlobalRate: 90,
                        localForce: 100,
                        nationalForce: 110,
                    }
                };
                return presets[presetName];
            }
            
            applyHistoricalPreset(presetName) {
                const preset = this.getHistoricalPreset(presetName);
                if (preset) {
                    this.setCustomRates(preset.localNationalRate / 100, preset.nationalGlobalRate / 100);
                    this.setAttractionForces(preset.localForce, preset.nationalForce);
                    return preset;
                }
                return null;
            }
            
            getStats() {
                const stats = {
                    mode: this.currentMode,
                    vortexStats: {},
                    totalParticles: 0,
                    distribution: {
                        national: 0,
                        global: 0
                    }
                };
                
                this.vortexes.forEach(vortex => {
                    const vortexStat = vortex.getStats();
                    const key = `${vortex.type}-${this.vortexes.indexOf(vortex)}`;
                    stats.vortexStats[key] = vortexStat;
                    
                    stats.totalParticles += vortex.particles.length;
                    stats.distribution[vortex.type] += vortex.particles.length;
                });
                
                return stats;
            }
            
            calculateCirculationEfficiency() {
                let totalParticles = 0;
                let homeParticles = 0;
                
                this.vortexes.forEach(vortex => {
                    vortex.particles.forEach(particle => {
                        totalParticles++;
                        if (particle.homeVortex === particle.currentVortex) {
                            homeParticles++;
                        }
                    });
                });
                
                return totalParticles > 0 ? (homeParticles / totalParticles) * 100 : 0;
            }
            
            calculateExchangeActivity() {
                let totalParticles = 0;
                let transferringParticles = 0;
                
                this.vortexes.forEach(vortex => {
                    vortex.particles.forEach(particle => {
                        totalParticles++;
                        if (particle.isTransferring) {
                            transferringParticles++;
                        }
                    });
                });
                
                return totalParticles > 0 ? (transferringParticles / totalParticles) * 100 : 0;
            }
        }

        // EconomyVisualization メインクラス
        class EconomyVisualization {
            constructor() {
                console.log('EconomyVisualization 初期化開始');
                
                this.canvas = document.getElementById('economy-canvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.config = new Config();
                
                this.vortexes = [];
                this.particles = [];
                
                this.controller = null;

                this.showConnections = true;
                this.showStats = false;

                this.animationId = null;
                this.isPaused = false;
                
                this.init();
            }
            
            init() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                this.createVortexes();
                this.connectVortexes();
                this.createParticles();
                
                this.controller = new CirculationController(this.vortexes, this.config);
                
                this.setupUI();
                this.animate();
            }
            
            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
            }
            
            createVortexes() {
                const globalPositions = this.config.getVortexPositions(
                    this.canvas.width,
                    this.canvas.height,
                    'global'
                );
                
                const globalRadius = this.config.vortexSizes.global;
                const nationalRadius = this.config.vortexSizes.national;

                globalPositions.forEach((globalPos, gIndex) => {
                    const globalVortex = new Vortex(globalPos.x, globalPos.y, globalRadius, 'global', this.config);
                    this.vortexes.push(globalVortex);

                    const nationalCount = 3;
                    const nationalDistance = globalRadius * 0.45;
                    const rotationOffset = (gIndex * Math.PI / 6);

                    for (let nIndex = 0; nIndex < nationalCount; nIndex++) {
                        const angle = (nIndex / nationalCount) * Math.PI * 2 + Math.PI / 6 + rotationOffset;
                        const nx = globalPos.x + Math.cos(angle) * nationalDistance;
                        const ny = globalPos.y + Math.sin(angle) * nationalDistance;

                        const nationalVortex = new Vortex(nx, ny, nationalRadius, 'national', this.config);
                        nationalVortex.parentVortex = globalVortex;
                        this.vortexes.push(nationalVortex);
                    }
                });
            }
            
            connectVortexes() {
                const nationalVortexes = this.vortexes.filter(v => v.type === 'national');
                const globalVortexes = this.vortexes.filter(v => v.type === 'global');

                nationalVortexes.forEach(national => {
                    if (national.parentVortex) {
                        national.connectTo(national.parentVortex);
                        national.parentVortex.connectTo(national);
                    }
                });

                globalVortexes.forEach(global => {
                    const childNationals = nationalVortexes.filter(n => n.parentVortex === global);
                    for (let i = 0; i < childNationals.length; i++) {
                        for (let j = i + 1; j < childNationals.length; j++) {
                            childNationals[i].connectTo(childNationals[j]);
                            childNationals[j].connectTo(childNationals[i]);
                        }
                    }
                });

                for (let i = 0; i < globalVortexes.length; i++) {
                    for (let j = i + 1; j < globalVortexes.length; j++) {
                        globalVortexes[i].connectTo(globalVortexes[j]);
                        globalVortexes[j].connectTo(globalVortexes[i]);
                    }
                }

                for (let i = 0; i < nationalVortexes.length; i++) {
                    for (let j = i + 1; j < nationalVortexes.length; j++) {
                        if (nationalVortexes[i].parentVortex !== nationalVortexes[j].parentVortex) {
                            nationalVortexes[i].connectTo(nationalVortexes[j]);
                            nationalVortexes[j].connectTo(nationalVortexes[i]);
                        }
                    }
                }
            }
            
            createParticles() {
                this.vortexes.forEach(vortex => {
                    const particleCount = this.config.particlesPerVortex[vortex.type] || 100;
                    
                    for (let i = 0; i < particleCount; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * vortex.radius * 0.7;
                        const x = vortex.x + Math.cos(angle) * distance;
                        const y = vortex.y + Math.sin(angle) * distance;
                        
                        const particle = new Particle(x, y, vortex, this.config);
                        this.particles.push(particle);
                        vortex.addParticle(particle);
                    }
                });
            }

            // 解説を表示するヘルパーメソッド
            updateExplanation(modeKey) {
                const data = EXPLANATIONS[modeKey];
                if (!data) return;

                const card = document.getElementById('explanation-card');
                const title = document.getElementById('exp-title');
                const subtitle = document.getElementById('exp-subtitle');
                const features = document.getElementById('exp-features');
                const merits = document.getElementById('exp-merits');
                const demerits = document.getElementById('exp-demerits');

                card.style.display = 'block';
                title.textContent = data.title;
                subtitle.textContent = data.subtitle;
                features.innerHTML = data.features;
                
                // リストを生成
                merits.innerHTML = data.merits.map(m => `<li>${m}</li>`).join('');
                demerits.innerHTML = data.demerits.map(d => `<li>${d}</li>`).join('');
            }
            
            setupUI() {
                const localNationalSlider = document.getElementById('local-national-rate');
                const nationalGlobalSlider = document.getElementById('national-global-rate');
                const localNationalValue = document.getElementById('local-national-value');
                const nationalGlobalValue = document.getElementById('national-global-value');

                const localStrengthSlider = document.getElementById('local-strength');
                const nationalStrengthSlider = document.getElementById('national-strength');
                const localStrengthValue = document.getElementById('local-strength-value');
                const nationalStrengthValue = document.getElementById('national-strength-value');

                const presetButtons = {
                    'feudal-btn': 'feudal',
                    'modern-nationalism-btn': 'modern-nationalism',
                    'globalism-btn': 'globalism',
                    'glocalism-btn': 'glocalism'
                };

                // 初期状態として解説を非表示にするか、デフォルトを表示するか
                // ここでは何も選択されていない状態からスタート

                Object.keys(presetButtons).forEach(btnId => {
                    const button = document.getElementById(btnId);
                    button.addEventListener('click', () => {
                        const modeKey = presetButtons[btnId];
                        const preset = this.controller.applyHistoricalPreset(modeKey);
                        if (preset) {
                            // UI更新
                            localNationalSlider.value = preset.localNationalRate;
                            localNationalValue.textContent = preset.localNationalRate;
                            nationalGlobalSlider.value = preset.nationalGlobalRate;
                            nationalGlobalValue.textContent = preset.nationalGlobalRate;
                            localStrengthSlider.value = preset.localForce;
                            localStrengthValue.textContent = preset.localForce;
                            nationalStrengthSlider.value = preset.nationalForce;
                            nationalStrengthValue.textContent = preset.nationalForce;

                            // アクティブクラス更新
                            document.querySelectorAll('.mode-btn').forEach(btn => {
                                btn.classList.remove('active');
                            });
                            button.classList.add('active');

                            // 解説を更新
                            this.updateExplanation(modeKey);
                        }
                    });
                });

                // 各種スライダーイベント（カスタムモードになったら解説をどうするか？
                // 現状はそのまま残すか、あるいは「カスタム」と表示するか。
                // 複雑さを避けるため、解説はそのまま残します）
                
                const handleCustomInput = () => {
                     document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
                };

                localNationalSlider.addEventListener('input', (e) => {
                    localNationalValue.textContent = e.target.value;
                    const nationalGlobalRate = parseInt(nationalGlobalSlider.value) / 100;
                    this.controller.setCustomRates(e.target.value / 100, nationalGlobalRate);
                    handleCustomInput();
                });

                nationalGlobalSlider.addEventListener('input', (e) => {
                    nationalGlobalValue.textContent = e.target.value;
                    const localNationalRate = parseInt(localNationalSlider.value) / 100;
                    this.controller.setCustomRates(localNationalRate, e.target.value / 100);
                    handleCustomInput();
                });

                localStrengthSlider.addEventListener('input', (e) => {
                    localStrengthValue.textContent = e.target.value;
                    const nationalStrength = parseInt(nationalStrengthSlider.value);
                    this.controller.setAttractionForces(e.target.value, nationalStrength);
                    handleCustomInput();
                });

                nationalStrengthSlider.addEventListener('input', (e) => {
                    nationalStrengthValue.textContent = e.target.value;
                    const localStrength = parseInt(localStrengthSlider.value);
                    this.controller.setAttractionForces(localStrength, e.target.value);
                    handleCustomInput();
                });
            }
            
            update() {
                if (this.isPaused) return;
                this.particles.forEach(particle => particle.update());
            }
            
            render() {
                this.ctx.fillStyle = '#1a1a2e';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                const globalVortexes = this.vortexes.filter(v => v.type === 'global');
                const nationalVortexes = this.vortexes.filter(v => v.type === 'national');

                globalVortexes.forEach(vortex => {
                    vortex.draw(this.ctx, this.showConnections);
                });

                nationalVortexes.forEach(vortex => {
                    vortex.draw(this.ctx, this.showConnections);
                });

                this.particles.forEach(particle => {
                    particle.draw(this.ctx);
                });
            }
            
            animate() {
                this.update();
                this.render();
                this.animationId = requestAnimationFrame(() => this.animate());
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            try {
                const app = new EconomyVisualization();
                window.economyApp = app;
                // 初期表示としてFeudalボタンを擬似クリックして解説を表示
                document.getElementById('feudal-btn').click();
            } catch(error) {
                console.error('アプリケーション起動エラー:', error);
            }
        });
    </script>
</body>
</html>