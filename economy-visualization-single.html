<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>経済循環の可視化 - グローバリズム・ナショナリズム・ローカリズム v2.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        h1 {
            font-size: 2.5em;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #7f8c8d;
            font-size: 1.1em;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #e0e0e0;
        }

        .control-group h3 {
            margin-bottom: 15px;
            color: #2c3e50;
            font-size: 1.2em;
        }

        .mode-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .mode-btn {
            padding: 12px 20px;
            border: 2px solid #3498db;
            background: white;
            color: #3498db;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .mode-btn:hover {
            background: #ebf5fb;
            transform: translateY(-2px);
        }

        .mode-btn.active {
            background: #3498db;
            color: white;
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .slider-group {
            margin-bottom: 15px;
        }

        .slider-group label {
            display: block;
            margin-bottom: 8px;
            color: #2c3e50;
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #d3d3d3;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.4);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.4);
            border: none;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer;
            color: #2c3e50;
        }

        .checkbox-label input[type="checkbox"] {
            margin-right: 10px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .canvas-container {
            position: relative;
            margin-bottom: 30px;
            background: #1a1a2e;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: inset 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        #economy-canvas {
            display: block;
            width: 100%;
            height: 600px;
        }

        .stats-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            font-size: 0.9em;
            min-width: 200px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .stats-panel h4 {
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .stats-panel div {
            margin-bottom: 5px;
            color: #555;
        }

        .legend {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .legend h3 {
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .legend-items {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .legend-color {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .legend-color.local {
            background: #e74c3c;
        }

        .legend-color.national {
            background: #3498db;
        }

        .legend-color.global {
            background: #2ecc71;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            h1 {
                font-size: 1.8em;
            }

            .controls {
                grid-template-columns: 1fr;
            }

            #economy-canvas {
                height: 400px;
            }

            .legend-items {
                flex-direction: column;
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>経済循環の可視化システム</h1>
            <p class="subtitle">3層構造の経済圏における資金循環モデル</p>
        </header>

        <div class="controls">
            <div class="control-group">
                <h3>カスタム設定</h3>
                <div class="slider-group">
                    <label for="internal-rate">
                        内部循環率: <span id="internal-value">70</span>%
                    </label>
                    <input type="range" id="internal-rate" min="10" max="95" value="70" step="5">
                </div>
                <div class="slider-group">
                    <label for="external-rate">
                        外部交換率: <span id="external-value">30</span>%
                    </label>
                    <input type="range" id="external-rate" min="5" max="90" value="30" step="5">
                </div>
            </div>

            <div class="control-group">
                <h3>表示設定</h3>
                <label class="checkbox-label">
                    <input type="checkbox" id="show-connections" checked>
                    渦間の接続を表示
                </label>
                <label class="checkbox-label">
                    <input type="checkbox" id="show-stats" checked>
                    統計情報を表示
                </label>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="economy-canvas"></canvas>
            <div id="stats" class="stats-panel"></div>
        </div>

        <div class="legend">
            <h3>凡例</h3>
            <div class="legend-items">
                <div class="legend-item">
                    <span class="legend-color local"></span>
                    <span>ローカル経済圏（小）</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color national"></span>
                    <span>ナショナル経済圏（中）</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color global"></span>
                    <span>グローバル経済圏（大）</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 全てのJavaScriptコードをここに統合
        console.log('スクリプト読み込み開始');

        // Config クラス
        class Config {
            constructor() {
                this.localVortexCount = 3;
                this.nationalVortexCount = 3;
                this.globalVortexCount = 3;
                
                this.defaultInternalRate = 0.7;
                this.defaultExternalRate = 0.3;
                
                // パーティクル数を渦の種類に応じて調整
                this.particlesPerVortex = {
                    local: 150,      // ローカル：50→150（3倍）
                    national: 300,   // ナショナル：100→300（3倍）
                    global: 450      // グローバル：150→450（3倍）
                };
                
                this.vortexSizes = {
                    local: 30,      // ナショナルの半分以下に
                    national: 70,   
                    global: 160     
                };
                
                this.vortexStrength = {
                    local: 0.7,     // ローカルの引力をさらに弱く
                    national: 1.5,
                    global: 2.8
                };
                
                this.colors = {
                    local: '#e74c3c',
                    national: '#3498db',
                    global: '#2ecc71',
                    exchange: '#f39c12',
                    connection: 'rgba(255, 255, 255, 0.1)'
                };
                
                this.particleSize = 2;    // パーティクルサイズ
                this.particleAlpha = 0.6; // 透明度
                
                this.friction = 0.98;     // 摩擦を減らして移動を促進（0.97→0.98）
                this.maxSpeed = 9;        // 最大速度を上げる（7→9）
                this.transferThreshold = 0.5;
            }
            
            getPresetMode(mode) {
                switch(mode) {
                    case 'extreme-globalism':
                        return {
                            internalRate: 0.05,    // 内部循環をほぼゼロに（0.2→0.05）
                            externalRate: 0.95,    // 外部交換をほぼ100%に（0.8→0.95）
                            strengthMultiplier: {
                                local: 0.1,        // ローカルの引力を超極小に（0.3→0.1）
                                national: 0.4,     // ナショナルも極弱に（0.8→0.4）
                                global: 15.0       // グローバルの引力を超極大に（8.0→15.0）
                            }
                        };
                    
                    case 'balanced':
                        return {
                            internalRate: 0.7,
                            externalRate: 0.3,
                            strengthMultiplier: {
                                local: 1.0,
                                national: 2.0,
                                global: 3.0
                            }
                        };
                    
                    case 'extreme-localism':
                        return {
                            internalRate: 0.95,   // 内部循環を極端に強く
                            externalRate: 0.05,   // 外部交換を極端に弱く
                            strengthMultiplier: {
                                local: 4.0,       // ローカルの引力を極大に
                                national: 1.0,
                                global: 0.3       // グローバルの引力を極小に
                            }
                        };
                    
                    default:
                        return this.getPresetMode('balanced');
                }
            }
            
            getPresetMode(mode) {
                switch(mode) {
                    case 'extreme-globalism':
                        return {
                            internalRate: 0.3,
                            externalRate: 0.7,
                            strengthMultiplier: {
                                local: 0.5,
                                national: 1.0,
                                global: 5.0
                            }
                        };
                    
                    case 'balanced':
                        return {
                            internalRate: 0.7,
                            externalRate: 0.3,
                            strengthMultiplier: {
                                local: 1.0,
                                national: 2.0,
                                global: 3.0
                            }
                        };
                    
                    case 'extreme-localism':
                        return {
                            internalRate: 0.9,
                            externalRate: 0.1,
                            strengthMultiplier: {
                                local: 3.0,
                                national: 1.5,
                                global: 0.5
                            }
                        };
                    
                    default:
                        return this.getPresetMode('balanced');
                }
            }
            
            getVortexPositions(canvasWidth, canvasHeight, type) {
                const positions = [];
                const count = this[`${type}VortexCount`];
                // 渦間の距離をさらに縮小（0.25 → 0.22）
                const radius = Math.min(canvasWidth, canvasHeight) * 0.22;
                
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2 + Math.PI / 2;
                    const x = canvasWidth / 2 + Math.cos(angle) * radius;
                    const y = canvasHeight / 2 + Math.sin(angle) * radius;
                    positions.push({ x, y });
                }
                
                return positions;
            }
        }

        // Vortex クラス
        class Vortex {
            constructor(x, y, radius, type, config) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.type = type;
                this.config = config;
                
                this.internalCirculationRate = config.defaultInternalRate;
                this.externalExchangeRate = config.defaultExternalRate;
                
                this.baseStrength = config.vortexStrength[type];
                this.currentStrength = this.baseStrength;
                
                this.particles = [];
                this.connectedVortexes = [];
                
                this.color = config.colors[type];
                this.pulsePhase = Math.random() * Math.PI * 2;
                
                // 親渦（入れ子構造用）
                this.parentVortex = null;
            }
            
            addParticle(particle) {
                if (!this.particles.includes(particle)) {
                    this.particles.push(particle);
                }
            }
            
            removeParticle(particle) {
                const index = this.particles.indexOf(particle);
                if (index > -1) {
                    this.particles.splice(index, 1);
                }
            }
            
            connectTo(vortex) {
                if (!this.connectedVortexes.includes(vortex)) {
                    this.connectedVortexes.push(vortex);
                }
            }
            
            calculateInternalForce(particle) {
                const dx = this.x - particle.x;
                const dy = this.y - particle.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 1) return { fx: 0, fy: 0 };
                
                // 内部循環率が高い = 自分の渦に強く引き寄せられる
                // 内部循環率が低い = 自分の渦に弱く引き寄せられる
                const force = (this.currentStrength * this.internalCirculationRate * 2.0) / (distance * 0.08);
                const angle = Math.atan2(dy, dx);
                
                const rotationAngle = angle + Math.PI / 2;
                const rotationForce = force * 0.3;
                
                return {
                    fx: Math.cos(angle) * force + Math.cos(rotationAngle) * rotationForce,
                    fy: Math.sin(angle) * force + Math.sin(rotationAngle) * rotationForce
                };
            }
            
            calculateExternalForce(particle) {
                let totalFx = 0;
                let totalFy = 0;
                
                for (const otherVortex of this.connectedVortexes) {
                    const dx = otherVortex.x - particle.x;
                    const dy = otherVortex.y - particle.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 1) continue;
                    
                    // 外部交換率が高い = 他の渦に強く引き寄せられる
                    // 外部交換率が低い = 他の渦に弱く引き寄せられる
                    const force = (otherVortex.currentStrength * this.externalExchangeRate * 6.0) / (distance * 0.08);
                    const angle = Math.atan2(dy, dx);
                    
                    totalFx += Math.cos(angle) * force;
                    totalFy += Math.sin(angle) * force;
                }
                
                return { fx: totalFx, fy: totalFy };
            }
            
            shouldTransferParticle(particle) {
                const dx = particle.x - this.x;
                const dy = particle.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // 外部交換率に応じて移動判定の閾値を動的に調整
                // 外部交換率が高い = より内側でも移動を開始
                const threshold = this.radius * (1.0 - this.externalExchangeRate * 0.5);
                
                if (distance > threshold) {
                    let closestVortex = null;
                    let closestDistance = Infinity;
                    
                    for (const vortex of this.connectedVortexes) {
                        const vdx = particle.x - vortex.x;
                        const vdy = particle.y - vortex.y;
                        const vdist = Math.sqrt(vdx * vdx + vdy * vdy);
                        
                        if (vdist < vortex.radius * 2.0 && vdist < closestDistance) {
                            closestDistance = vdist;
                            closestVortex = vortex;
                        }
                    }
                    
                    // 外部交換率が高いほど移動確率が上がる
                    if (closestVortex && Math.random() < this.externalExchangeRate * 6) {
                        return closestVortex;
                    }
                }
                
                // ランダム移動も外部交換率に比例
                if (Math.random() < this.externalExchangeRate * 0.05) {
                    const randomIndex = Math.floor(Math.random() * this.connectedVortexes.length);
                    return this.connectedVortexes[randomIndex];
                }
                
                return null;
            }
            
            updateCirculationRates(internal, external) {
                this.internalCirculationRate = internal;
                this.externalExchangeRate = external;
            }
            
            updateStrength(multiplier) {
                this.currentStrength = this.baseStrength * multiplier;
            }
            
            draw(ctx, showConnections = true) {
                this.pulsePhase += 0.02;
                const pulse = Math.sin(this.pulsePhase) * 0.1 + 0.9;
                
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.radius * pulse
                );
                gradient.addColorStop(0, `${this.color}40`);
                gradient.addColorStop(0.5, `${this.color}20`);
                gradient.addColorStop(1, `${this.color}00`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * pulse, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.3, 0, Math.PI * 2);
                ctx.stroke();
                
                if (showConnections) {
                    ctx.strokeStyle = this.config.colors.connection;
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    
                    for (const vortex of this.connectedVortexes) {
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(vortex.x, vortex.y);
                        ctx.stroke();
                    }
                    
                    ctx.setLineDash([]);
                }
            }
            
            getStats() {
                return {
                    type: this.type,
                    particleCount: this.particles.length,
                    internalRate: (this.internalCirculationRate * 100).toFixed(0),
                    externalRate: (this.externalExchangeRate * 100).toFixed(0)
                };
            }
        }

        // Particle クラス
        class Particle {
            constructor(x, y, homeVortex, config) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                
                this.homeVortex = homeVortex;
                this.currentVortex = homeVortex;
                
                this.config = config;
                this.size = config.particleSize;
                this.alpha = config.particleAlpha;
                
                this.color = homeVortex.color;
                this.isTransferring = false;
                
                this.trail = [];
                this.maxTrailLength = 10;
            }
            
            calculateForces() {
                const internal = this.currentVortex.calculateInternalForce(this);
                const external = this.currentVortex.calculateExternalForce(this);
                
                this.vx += internal.fx + external.fx;
                this.vy += internal.fy + external.fy;
                
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > this.config.maxSpeed) {
                    this.vx = (this.vx / speed) * this.config.maxSpeed;
                    this.vy = (this.vy / speed) * this.config.maxSpeed;
                }
                
                this.vx *= this.config.friction;
                this.vy *= this.config.friction;
            }
            
            checkTransfer() {
                const targetVortex = this.currentVortex.shouldTransferParticle(this);
                
                if (targetVortex) {
                    this.currentVortex.removeParticle(this);
                    this.currentVortex = targetVortex;
                    this.currentVortex.addParticle(this);
                    
                    this.isTransferring = true;
                    setTimeout(() => {
                        this.isTransferring = false;
                    }, 500);
                }
            }
            
            update() {
                this.calculateForces();
                
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
                
                this.x += this.vx;
                this.y += this.vy;
                
                this.checkTransfer();
            }
            
            draw(ctx) {
                if (this.trail.length > 1) {
                    ctx.strokeStyle = `${this.color}30`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    
                    for (let i = 1; i < this.trail.length; i++) {
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    ctx.stroke();
                }
                
                const displayColor = this.isTransferring 
                    ? this.config.colors.exchange 
                    : this.color;
                
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.size * 2
                );
                gradient.addColorStop(0, `${displayColor}${Math.floor(this.alpha * 255).toString(16)}`);
                gradient.addColorStop(1, `${displayColor}00`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = displayColor;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // CirculationController クラス
        class CirculationController {
            constructor(vortexes, config) {
                this.vortexes = vortexes;
                this.config = config;
                this.currentMode = 'balanced';
            }
            
            setMode(mode) {
                this.currentMode = mode;
                const preset = this.config.getPresetMode(mode);
                this.applyPreset(preset);
            }
            
            applyPreset(preset) {
                this.vortexes.forEach(vortex => {
                    vortex.updateCirculationRates(
                        preset.internalRate,
                        preset.externalRate
                    );
                    
                    const multiplier = preset.strengthMultiplier[vortex.type];
                    vortex.updateStrength(multiplier);
                });
            }
            
            setCustomRates(internalRate, externalRate) {
                this.currentMode = 'custom';
                
                const total = internalRate + externalRate;
                const adjustedInternal = internalRate / total;
                const adjustedExternal = externalRate / total;
                
                this.vortexes.forEach(vortex => {
                    vortex.updateCirculationRates(adjustedInternal, adjustedExternal);
                });
            }
            
            setExtremeGlobalism() {
                this.setMode('extreme-globalism');
            }
            
            setBalanced() {
                this.setMode('balanced');
            }
            
            setExtremeLocalism() {
                this.setMode('extreme-localism');
            }
            
            getStats() {
                const stats = {
                    mode: this.currentMode,
                    vortexStats: {},
                    totalParticles: 0,
                    distribution: {
                        local: 0,
                        national: 0,
                        global: 0
                    }
                };
                
                this.vortexes.forEach(vortex => {
                    const vortexStat = vortex.getStats();
                    const key = `${vortex.type}-${this.vortexes.indexOf(vortex)}`;
                    stats.vortexStats[key] = vortexStat;
                    
                    stats.totalParticles += vortex.particles.length;
                    stats.distribution[vortex.type] += vortex.particles.length;
                });
                
                return stats;
            }
            
            calculateCirculationEfficiency() {
                let totalParticles = 0;
                let homeParticles = 0;
                
                this.vortexes.forEach(vortex => {
                    vortex.particles.forEach(particle => {
                        totalParticles++;
                        if (particle.homeVortex === particle.currentVortex) {
                            homeParticles++;
                        }
                    });
                });
                
                return totalParticles > 0 ? (homeParticles / totalParticles) * 100 : 0;
            }
            
            calculateExchangeActivity() {
                let totalParticles = 0;
                let transferringParticles = 0;
                
                this.vortexes.forEach(vortex => {
                    vortex.particles.forEach(particle => {
                        totalParticles++;
                        if (particle.isTransferring) {
                            transferringParticles++;
                        }
                    });
                });
                
                return totalParticles > 0 ? (transferringParticles / totalParticles) * 100 : 0;
            }
        }

        // EconomyVisualization メインクラス
        class EconomyVisualization {
            constructor() {
                console.log('EconomyVisualization 初期化開始');
                
                this.canvas = document.getElementById('economy-canvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.config = new Config();
                
                this.vortexes = [];
                this.particles = [];
                
                this.controller = null;
                
                this.showConnections = true;
                this.showStats = true;
                
                this.animationId = null;
                this.isPaused = false;
                
                this.init();
            }
            
            init() {
                console.log('init() 開始');
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                this.createVortexes();
                console.log(`渦を作成: ${this.vortexes.length}個`);
                
                this.connectVortexes();
                console.log('渦を接続しました');
                
                this.createParticles();
                console.log(`パーティクルを作成: ${this.particles.length}個`);
                
                this.controller = new CirculationController(this.vortexes, this.config);
                console.log('コントローラー初期化完了');
                
                this.setupUI();
                console.log('UI設定完了');
                
                this.animate();
                console.log('アニメーション開始');
            }
            
            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                console.log(`キャンバスサイズ: ${this.canvas.width}x${this.canvas.height}`);
            }
            
            createVortexes() {
                // グローバル渦を3つ作成（大円配置）
                const globalPositions = this.config.getVortexPositions(
                    this.canvas.width,
                    this.canvas.height,
                    'global'
                );
                
                const globalRadius = this.config.vortexSizes.global;
                const nationalRadius = this.config.vortexSizes.national;
                const localRadius = this.config.vortexSizes.local;
                
                globalPositions.forEach((globalPos, gIndex) => {
                    // グローバル渦を作成
                    const globalVortex = new Vortex(globalPos.x, globalPos.y, globalRadius, 'global', this.config);
                    this.vortexes.push(globalVortex);
                    
                    // 各グローバル渦の中に3つのナショナル渦を配置
                    const nationalCount = 3;
                    const nationalDistance = globalRadius * 0.45; // グローバル渦の半径の45%の位置
                    
                    for (let nIndex = 0; nIndex < nationalCount; nIndex++) {
                        const angle = (nIndex / nationalCount) * Math.PI * 2 + Math.PI / 6;
                        const nx = globalPos.x + Math.cos(angle) * nationalDistance;
                        const ny = globalPos.y + Math.sin(angle) * nationalDistance;
                        
                        const nationalVortex = new Vortex(nx, ny, nationalRadius, 'national', this.config);
                        nationalVortex.parentVortex = globalVortex;
                        this.vortexes.push(nationalVortex);
                        
                        // ローカル渦をナショナル渦の中心に配置（同じ位置）
                        const localVortex = new Vortex(nx, ny, localRadius, 'local', this.config);
                        localVortex.parentVortex = nationalVortex;
                        this.vortexes.push(localVortex);
                    }
                });
            }
            
            connectVortexes() {
                const localVortexes = this.vortexes.filter(v => v.type === 'local');
                const nationalVortexes = this.vortexes.filter(v => v.type === 'national');
                const globalVortexes = this.vortexes.filter(v => v.type === 'global');
                
                // 1. ローカル ⟷ 親ナショナル（同じ位置にある）
                localVortexes.forEach(local => {
                    if (local.parentVortex) {
                        local.connectTo(local.parentVortex);
                        local.parentVortex.connectTo(local);
                    }
                });
                
                // 2. ナショナル ⟷ 親グローバル
                nationalVortexes.forEach(national => {
                    if (national.parentVortex) {
                        national.connectTo(national.parentVortex);
                        national.parentVortex.connectTo(national);
                    }
                });
                
                // 3. 同じグローバル内のナショナル同士を接続
                globalVortexes.forEach(global => {
                    const childNationals = nationalVortexes.filter(n => n.parentVortex === global);
                    for (let i = 0; i < childNationals.length; i++) {
                        for (let j = i + 1; j < childNationals.length; j++) {
                            childNationals[i].connectTo(childNationals[j]);
                            childNationals[j].connectTo(childNationals[i]);
                        }
                    }
                });
                
                // 4. 同じナショナル内のローカル同士を接続（同位置なので実質的には意味が薄い）
                // （オプション：省略可能）
                
                // 5. グローバル同士を接続
                for (let i = 0; i < globalVortexes.length; i++) {
                    for (let j = i + 1; j < globalVortexes.length; j++) {
                        globalVortexes[i].connectTo(globalVortexes[j]);
                        globalVortexes[j].connectTo(globalVortexes[i]);
                    }
                }
                
                // 6. 異なるグローバルのナショナル同士も接続（国際的な交流）
                for (let i = 0; i < nationalVortexes.length; i++) {
                    for (let j = i + 1; j < nationalVortexes.length; j++) {
                        // 親が異なる場合のみ接続
                        if (nationalVortexes[i].parentVortex !== nationalVortexes[j].parentVortex) {
                            nationalVortexes[i].connectTo(nationalVortexes[j]);
                            nationalVortexes[j].connectTo(nationalVortexes[i]);
                        }
                    }
                }
            }
            
            findClosestVortex(targetVortex, candidateVortexes) {
                let closest = null;
                let minDistance = Infinity;
                
                candidateVortexes.forEach(vortex => {
                    const dx = vortex.x - targetVortex.x;
                    const dy = vortex.y - targetVortex.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closest = vortex;
                    }
                });
                
                return closest;
            }
            
            createParticles() {
                this.vortexes.forEach(vortex => {
                    // 渦の種類に応じたパーティクル数を取得
                    const particleCount = this.config.particlesPerVortex[vortex.type] || 100;
                    
                    for (let i = 0; i < particleCount; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * vortex.radius * 0.7;
                        const x = vortex.x + Math.cos(angle) * distance;
                        const y = vortex.y + Math.sin(angle) * distance;
                        
                        const particle = new Particle(x, y, vortex, this.config);
                        this.particles.push(particle);
                        vortex.addParticle(particle);
                    }
                });
            }
            
            setupUI() {
                const internalSlider = document.getElementById('internal-rate');
                const externalSlider = document.getElementById('external-rate');
                const internalValue = document.getElementById('internal-value');
                const externalValue = document.getElementById('external-value');
                
                internalSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    internalValue.textContent = value;
                    externalSlider.value = 100 - value;
                    externalValue.textContent = 100 - value;
                    this.controller.setCustomRates(value / 100, (100 - value) / 100);
                });
                
                externalSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    externalValue.textContent = value;
                    internalSlider.value = 100 - value;
                    internalValue.textContent = 100 - value;
                    this.controller.setCustomRates((100 - value) / 100, value / 100);
                });
                
                document.getElementById('show-connections').addEventListener('change', (e) => {
                    this.showConnections = e.target.checked;
                });
                
                document.getElementById('show-stats').addEventListener('change', (e) => {
                    this.showStats = e.target.checked;
                    document.getElementById('stats').style.display = e.target.checked ? 'block' : 'none';
                });
            }
            
            update() {
                if (this.isPaused) return;
                
                this.particles.forEach(particle => particle.update());
            }
            
            render() {
                this.ctx.fillStyle = '#1a1a2e';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // 渦を大きい順に描画（グローバル→ナショナル→ローカル）
                const globalVortexes = this.vortexes.filter(v => v.type === 'global');
                const nationalVortexes = this.vortexes.filter(v => v.type === 'national');
                const localVortexes = this.vortexes.filter(v => v.type === 'local');
                
                globalVortexes.forEach(vortex => {
                    vortex.draw(this.ctx, this.showConnections);
                });
                
                nationalVortexes.forEach(vortex => {
                    vortex.draw(this.ctx, this.showConnections);
                });
                
                localVortexes.forEach(vortex => {
                    vortex.draw(this.ctx, this.showConnections);
                });
                
                // パーティクルを描画
                this.particles.forEach(particle => {
                    particle.draw(this.ctx);
                });
                
                if (this.showStats) {
                    this.updateStats();
                }
            }
            
            updateStats() {
                const stats = this.controller.getStats();
                const efficiency = this.controller.calculateCirculationEfficiency();
                const activity = this.controller.calculateExchangeActivity();
                
                const statsHTML = `
                    <h4>統計情報</h4>
                    <div><strong>総パーティクル数:</strong> ${stats.totalParticles}</div>
                    <div style="margin-top: 10px;"><strong>分布:</strong></div>
                    <div>・ローカル: ${stats.distribution.local}</div>
                    <div>・ナショナル: ${stats.distribution.national}</div>
                    <div>・グローバル: ${stats.distribution.global}</div>
                    <div style="margin-top: 10px;"><strong>循環効率:</strong> ${efficiency.toFixed(1)}%</div>
                    <div><strong>交換活動度:</strong> ${activity.toFixed(1)}%</div>
                `;
                
                document.getElementById('stats').innerHTML = statsHTML;
            }
            
            getModeLabel(mode) {
                const labels = {
                    'extreme-globalism': '極端なグローバリズム',
                    'balanced': 'バランス型',
                    'extreme-localism': '極端なローカリズム',
                    'custom': 'カスタム'
                };
                return labels[mode] || mode;
            }
            
            animate() {
                this.update();
                this.render();
                this.animationId = requestAnimationFrame(() => this.animate());
            }
        }

        // アプリケーション起動
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOMContentLoaded イベント発火');
            try {
                const app = new EconomyVisualization();
                window.economyApp = app;
                console.log('アプリケーション起動成功');
            } catch(error) {
                console.error('アプリケーション起動エラー:', error);
            }
        });

        console.log('スクリプト読み込み完了');
    </script>
</body>
</html>
